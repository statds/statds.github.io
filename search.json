[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Blog",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n\n\n\n\n\n\nUsing jupyter on an HPC cluster\n\n\n\n\n\n\n\n\n\nJun 9, 2022\n\n\nLucas Godoy\n\n\n3 min\n\n\n\n\n\n\n\n\nAll models are wrong\n\n\n\n\n\n\n\n\n\nAug 15, 2021\n\n\nLucas Godoy\n\n\n1 min\n\n\n\n\n\n\n\n\nEstimating regression coefficients using a Neural Network (from scratch)\n\n\n\n\n\n\n\n\n\nJul 28, 2021\n\n\nLucas Godoy\n\n\n47 min\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Statistical Data Science Lab",
    "section": "",
    "text": "Hello there, I’m Lucas, a Ph.D. candidate studying Statistics at the UConn Department. My research interests primarily revolve around statistical computing, Bayesian inference, spatial statistics, and exploring innovative applications of statistical methodologies. Apart from that, I enjoy learning about programming languages and emerging technologies.\nIf you browse through this website, you’ll find some of my blog posts, mainly discussing R or statistical concepts, as well as my CV, publications, and ongoing projects."
  },
  {
    "objectID": "posts/jupyter_hpc/jupyter_hpc.html",
    "href": "posts/jupyter_hpc/jupyter_hpc.html",
    "title": "Using jupyter on an HPC cluster",
    "section": "",
    "text": "The purpose of this post is to enable cluster users to run jupyter on the cluster interactively, enabling them to conduct data analysis and visualization. There are different “flavors” of jupyter notebooks, the most appropriate are going to be pointed out at picking a container."
  },
  {
    "objectID": "posts/jupyter_hpc/jupyter_hpc.html#preliminaries",
    "href": "posts/jupyter_hpc/jupyter_hpc.html#preliminaries",
    "title": "Using jupyter on an HPC cluster",
    "section": "Preliminaries",
    "text": "Preliminaries\nWe assume that the user has access to ssh through a terminal. In addition, it is necessary to have SingularityCE (singularity for short) installed on a computer on which you have root privileges.\n\nIn order to use singularity on a Windows (or Mac) machine, a Linux Virtual Machine(VM) needs to be set up. Setting up a VM and installing SingularityCE os beyond the scope of this document.\n\nIn addition, singularity is assumed to be available on the HPC that you have access to. Usually, users have to run\n\nmodule load singularity/<version>\n\nbefore using it.\nFamiliarity with containers is helpful but not necessary. Loosely speaking, a container allows us to “isolate” a set of tools and software in order to guarantee code reproducibility and portability. Moreover, singularity was developed (among other reasons) to integrate these tools with HPC clusters."
  },
  {
    "objectID": "posts/jupyter_hpc/jupyter_hpc.html#pick-cont",
    "href": "posts/jupyter_hpc/jupyter_hpc.html#pick-cont",
    "title": "Using jupyter on an HPC cluster",
    "section": "Picking a container",
    "text": "Picking a container\nThe Jupyter Docker Stacks contains several useful docker containers that can be easily used to build singularity containers.\nA list of the containers (along with their principal features) maintained by the Jupyter team can be found here. Some of these containers are detailed below\n\njupyter/r-notebook: a container containing a basic installation for Machine Learning using R.\njupyter/scipy-notebook: contains popular libraries for scientific computing using python.\njupyter/tensorflow-notebook: this is the jupyter/scipy-notebook with tensorflow installed on it.\njupyter/datascience-notebook: includes libraries for data analysis from the julia, python, andR` communities."
  },
  {
    "objectID": "posts/jupyter_hpc/jupyter_hpc.html#converting-a-docker-into-a-singularity-container",
    "href": "posts/jupyter_hpc/jupyter_hpc.html#converting-a-docker-into-a-singularity-container",
    "title": "Using jupyter on an HPC cluster",
    "section": "Converting a docker into a singularity container",
    "text": "Converting a docker into a singularity container\nOnce you have chosen a container suitable for your needs (and have root access to a machine with singularity), a singularity container can be generated by executing the following chunk of code in the terminal.\n\n## singularity pull <choose-a-name>.sif docker://jupyter/<preferred-notebook>\nsingularity pull mycontainer.sif docker://jupyter/datascience-notebook\n\nIn the example above, I choose to use the datascience-notebook. After doing so, the .sif file generated by singularity needs to be transferred to the cluster. My personal preference is to use either scp or rsync, for example\n\nrsync mycontainer.sif <username>@<hpc-url>:<location>"
  },
  {
    "objectID": "posts/jupyter_hpc/jupyter_hpc.html#using-the-singularity-container-on-the-cluster",
    "href": "posts/jupyter_hpc/jupyter_hpc.html#using-the-singularity-container-on-the-cluster",
    "title": "Using jupyter on an HPC cluster",
    "section": "Using the singularity container on the cluster",
    "text": "Using the singularity container on the cluster\nAfter transferring the .sif file to the cluster, follow the following steps. Firstly, set up the VPN and log-in to the cluster using ssh, then navigate to the location where you transferred the container (.sif) to. Next, you will have to start a interactive job. If the workload manager used in the HPC that you have access to is SLURM, this can be done either with srun or fisbatch. To start an interactive job with srun use\n\nsrun --partition=<partition-name> --qos=<queue-name> --mem=64G --pty bash\n\nThe same task can be achieved with fisbatch (if available) with\n\nfisbatch --partition=<partition-name> --qos=<queue-name> --mem=64G\n\nEither of these commands will allocate your job to a specific node. It is important to save the name of the node that your job has been allocated to. Next, load singularity on that node as follows\n\nmodule load singularity/<version>\n\nThe penultimate step is to start the jupyter instance. It is done as follows\n\nsingularity exec --nv mycontainer.sif jupyter notebook --no-browser --ip='*'\n\nAfter executing the last chunk of code, the terminal will be “busy” and will provide three URLs, they will look somewhat like “http://127.0.0.1:8888/” this. Copy the last address provided by the output. The last step before being able to access the notebook through the provided address is to create a ssh tunnel. To do so, open another terminal window and execute\n\nssh -NL localhost:8888:<node>:8888 <username>@<hpc-url>\n\nwhere <node> should be replaced by the node to which the job submitted using srun (or fisbatch) was submitted to. This tunnel will keep the other terminal window busy to.\nFinally, copy the address provided by the notebook (e.g., “http://127.0.0.1:8888/”) and paste it into your browser."
  },
  {
    "objectID": "posts/lmnet/2021-06-23-lmnnet.html#intro",
    "href": "posts/lmnet/2021-06-23-lmnnet.html#intro",
    "title": "Estimating regression coefficients using a Neural Network (from scratch)",
    "section": "Intro",
    "text": "Intro\nThe idea behind the Neural Networks models, as its nomenclature suggests, is to mimic the way human brain learns to execute of some tasks. Some works in the literature (Cheng and Titterington (1994), Stern (1996), Warner and Misra (1996)) attribute of the first attempts to build a “Neural Network emulator” to McCulloch and Pitts (1943). The popularity of this method in the past decades was held down by the computation intensive calculations needed for such procedures. However, the computation resources advances in the last few years allied to the algorithmic nature of Neural Networks have contributed to the adoption of the methodology by computer scientists. These days, this models are very popular in the industry and are applied to several interesting applications such as speech recognition, image classification, and automatic text translation."
  },
  {
    "objectID": "posts/lmnet/2021-06-23-lmnnet.html#neural-network-regression",
    "href": "posts/lmnet/2021-06-23-lmnnet.html#neural-network-regression",
    "title": "Estimating regression coefficients using a Neural Network (from scratch)",
    "section": "Neural Network Regression",
    "text": "Neural Network Regression\nA neural network is a highly parametrized model that, provided we have enough data, can approximate any functional relationship between a set of features1 \\(\\mathbf{x}\\) and a response variable \\(y\\) (Efron and Hastie (2016), pages 151-152). Although there are several possible structures for neural networks, for this post we are going to consider only the feed-forward2 neural networks. In order to explain how these neural networks are designed, let’s consider its graphical representation (see Figure 1). We have vertices, which are called a units (or neurons), ordered horizontally by layers. An edge coming from one vertex can only be connected to vertices associated with “higher” layers. These connections represent a information flow from left to right (hence, the name feed-forward), where each unit computed by 1) giving weights to each of its inputs, 2) calculating the dot product between weights and inputs, 3) adding a constant( usually referred to as bias) to it, and, finally, 4) applying an element-wise activation function \\(f(\\cdot)\\) to it. These activation functions are used to establish non-linear relationships between units.\nThe number of hidden layers as well as the number of units associated with every layer can both be regard as tuning parameters. The design and architecture of a neural network is a complex task. In summary, when having a single hidden layer, the number of units associated with the hidden layer determines the number of parameters associated with the model. Efron and Hastie (2016) suggest that, under this scenario, it is better to consider several units for the hidden layer and use some kind of regularization to avoid overfitting. Penalizations analogous to the Ridge and Lasso penalty for linear models are often used in the regularization context for neural networks (Hastie, Tibshirani, and Wainwright (2015), pages 210-211).\nAn important remark regarding the neural network models is that they are “pure prediction algorithms”. That is, these models are focused only on prediction, neglecting the estimation, as pointed by Efron (2020). The strategy is simple and consists in searching for high predictive accuracy. That being said, these algorithms make no assumption on the probability distribution of the data and, as one of the consequences of losing these assumptions, it is not possible to make interval predictions or to calculate confidence intervals for the “estimated” parameters.\n\n\n\n\n\nFigure 1: A feed-forward neural network with a single hidden layer.\n\n\n\n\n\nSingle neuron feed-forward networks\nA single neuron feed-forward network does not possess any hidden layer in its structure. The absence of hidden layers makes these models resemble the statistical models we are most used to, like, for example, the linear regression and logistic regression. By analyzing the graphical representation of a single layer feed-forward network (Figure 2), it is easy to see that by taking the identity as the activation function, the functional relationship between \\(\\mathbf{x}\\) and \\(y\\) considered by the neural network is equivalent to the one used for the general linear model. Considering the same representation, if we take \\(f(x) = \\textrm{logit}(x)\\) (sigmoid function, according to the neural network models literature) and \\(y \\in \\{ 0, 1 \\}\\), then the neural network provides the same relationship between \\(\\mathbf{x}\\) and \\(y\\) as the one used by the logistic regression.\n\n\n\n\n\nFigure 2: A single layer feed-forward neural network.\n\n\n\n\nAlthough the functional relationship between \\(\\mathbf{x}\\) and \\(y\\) assumed by the single layer neural network coincides with some statistical models, we cannot promptly claim an equivalence between models because the way the neural networks learn, that is estimates, the weights can lead to different solutions depending on the loss and cost functions selected, we are going to talk more about these functions in the next section.\n\n\nActivation functions\nActivation functions are applied in every “Layer connection” in neural network models. Suppose, for example, we have a design matrix \\(\\mathbf{X} \\in {\\rm I\\!R}^{n \\times p}\\), and a response variable \\(\\mathbf{y}\\). Then, given appropriate choices of the \\(K - 1\\) (one for each layer connection), the mathematical model, for a single observation, behind the neural network, can be written in a vectorial notation as follows \\[\n\\mathbf{z}^{(k)} = \\mathbf{W}^{(k - 1)} \\mathbf{a}^{(k - 1)}\n\\] \\[\n\\mathbf{a}^{(k)} = f_{(k)} \\left( \\mathbf{z}^{(k)} \\right),\n\\] where \\(\\mathbf{W}^{(k - 1)} \\in {\\rm I\\!R}^{m_{k - 1} \\times m_{k}}\\) is the matrix of weights that go from from the layer \\(L_{k - 1}\\) to the layer \\(L_{k}\\), \\(\\mathbf{a}^{(k)} \\in {\\rm I\\!R}^{m_k \\times m_{k + 1}}\\) matrix of units at layer \\(L_k\\), and \\(f_{(k)}\\) is a (element-wise) activation function used at the layer \\(L_k\\). Note that, when \\(k = 0\\), then \\(\\mathbf{a}^{(0)} = \\mathbf{X}\\). Observe that \\(m_k\\) is the number of units in the layer \\(k\\) and, consequently, for the input and output layers, respectively, we have \\(m_0 = p\\) and \\(m_K = 1\\).\nFrom this example, it is clear that we can apply different activation functions when connecting different layers. Nevertheless, the activation for one layer is the same along all of its units.\nAlthough, theoretically, there exists no restriction on which functions to use as activation function, we want these functions to be at least one time differentiable. This is due to the fact that most of the methods used to find the optimal weights are based on gradients. Another aspect to be considered when choosing an activation function is the domain of the output variable \\(y\\). That is, if \\(y \\in [0, 1]\\), we want an activation function that maps real values to the \\([0, 1]\\) interval. In summary, for the output layer, we use a activation function that makes predictions on the same domain as the output variable, while, for hidden layers, we have no restrictions on the activation functions, besides the ones already mentioned.\nSome commonly used link functions are the \\(\\textrm{logit}\\), or sigmoid, function, defined as \\[\nf(x) = \\frac{1}{1 + e^{-x}},\n\\] the hyperbolic tangent function, referred to as \\(\\textrm{tanh}\\), \\[\nf(x) = \\frac{e^z - e^{-z}}{e^{z} + e^{-z}}.\n\\] Note that the \\(\\textrm{tanh}\\) is mapping from the real line to the \\((-1, 1)\\) interval. The Rectified Linear Unit (ReLU) is also a popular choice and is defined as \\[\nf(x) = x_{+} = \\max(0, x),\n\\] the main advantage of this function is a cheap to compute gradient. A different version of the ReLU called leaky ReLU is also quite popular, its definition is given as follows \\[\nf(x) = x_{+} = \\max(.01 * x, x),\n\\]\nThese are only some examples of commonly used activation functions and they are illustrated in Figure 3. The user does need to be restrict to these options since there are several other functions implemented in the software available to compute neural networks. However, if you want to use a activation function that is not implemented yet, you may have to implement your own version for the algorithm.\n\n\n\n\n\nFigure 3: The most popular activation functions (figure inspired by Figure 18.6 from Efron and Hastie (2016) ).\n\n\n\n\nAlthough there are no restrictions on the functions used as activation functions in the hidden layers (besides being differentiable functions), it is not advisable to use the identity function because it implies a waste of computational power. This is due to the fact that using a linear function in a hidden layer, makes the units from that layer a linear combination of the units from the previous layer. To make this clear, let’s prove that a Neural Network model with a single hidden layer collapses to a Generalized Linear Model when the identity function is used as the activation function.\nSuppose a \\(n\\)-dimensional vector \\(\\mathbf{y}\\) is assumed to follow a distribution \\(\\mathcal{P}\\), where \\(\\mathcal{P}\\) belongs to the exponential family of distributions. Then, given a design matrix \\(\\mathbf{X} \\in {\\rm I\\!R}^{n \\times p}\\), the Generalized Linear Model for \\(\\mathbf{y}\\) is composed by the random component, given by the probability density function associated with the distribution \\(\\mathcal{P}\\), the systematic component, defined by \\[\n\\boldsymbol{\\eta} = \\mathbf{X} \\boldsymbol{\\beta},\n\\tag{1}\\] and a (canonical) link function \\(g(\\cdot)\\) such that \\[\n\\boldsymbol{\\mu} = g(\\boldsymbol{\\eta}).\n\\tag{2}\\] Once we estimate the parameters \\(\\boldsymbol{\\beta}\\), we have \\[\n\\hat{\\mathbf{y}} = g( \\mathbf{X} \\hat{\\boldsymbol{\\beta}} ).\n\\]\nDefine now our Neural Network model having a single hidden layer with \\(M\\) units. The activation function for the hidden layer is \\(f_h(x) = g(x)\\), that is, the same as the identity function. The weights we want to find are \\(\\mathbf{W}^{(1)} \\in {\\rm I\\!R}^{p \\times 1}\\), and \\(\\mathbf{W}^{(2)} \\in {\\rm I\\!R}^{M \\times n}\\). The activation function for the activation layer is the previously mentioned canonical link function. Finally, let the loss be the deviance residual associated with the distribution \\(\\mathcal{P}\\), and the cost function be the average of the losses. Then, the mathematical representation of the Neural Network becomes \\[\n\\mathbf{z}^{(1)} = \\mathbf{X} \\mathbf{W}^{(1)} = \\mathbf{a}^{(1)},\n\\tag{3}\\] because the activation function for the hidden layer is the identity. Then, we have \\[\n\\mathbf{z}^{(2)} = \\mathbf{a}^{(1)} \\mathbf{W}^{(2)}\n\\tag{4}\\] \\[\n\\mathbf{y} = \\mathbf{a}^{(2)} = g( \\mathbf{\\mathbf{z}^{(2)}} ).\n\\tag{5}\\] However, note that, by combining 3, 4, and 5 we get \\[\\begin{align*}\n\\mathbf{y} & = g( \\mathbf{\\mathbf{z}^{(2)}} ) \\\\\n& = g( \\mathbf{a}^{(1)} \\mathbf{W}^{(2)} ) \\\\\n& = g( \\mathbf{X} \\underbrace{\\mathbf{W}^{(1)} \\mathbf{W}^{(2)}}_{{\\rm I\\!R}_{p\n\\times 1}} ),\n\\end{align*}\\] which yields to optimal weights (see Fitting a Neural Network and Backpropagation, for more information on how to fit a neural network model) satisfying \\[\n\\underbrace{\\mathbf{W}^{(1)} \\mathbf{W}^{(2)}}_{{\\rm I\\!R}_{p\n\\times 1}} = \\hat{\\boldsymbol{\\beta}},\n\\] where \\(\\hat{\\boldsymbol{\\beta}}\\) is the Maximum Likelihood Estimator for \\(\\boldsymbol{\\beta}\\) that can be obtained using the Iterative Reweighted Least Squares for the model defined by the probability density function associated with the distribution \\(\\mathcal{P}\\), the systematic component 1 and a (canonical) link function 2.\n\n\nCost functions\nWhenever we want to fit a neural network to a dataset we need to specify a Cost function, which is usually based on loss functions. A loss function, in the context of Neural Network models, measures how far our predictions \\(f(\\mathbf{x}; \\mathbf{W})\\) are from the true value \\(y\\). Examples of commonly used loss functions, for a single observation, are the mean square error loss and the binomial deviance defined, respectively, as \\[\nL(\\mathbf{w}, \\mathbf{x}; y) = \\frac{1}{2} (f(\\mathbf{x}; \\mathbf{w}) - y)^{2},\n\\tag{6}\\] and \\[\nL(\\mathbf{W}, \\mathbf{x}; y) = y \\log \\left( \\frac{y}{f(\\mathbf{x}, \\mathbf{w})}\n\\right) +\n(1 - y) \\log \\left( \\frac{1 - y}{1 - f(\\mathbf{x}, \\mathbf{w})} \\right).\n\\tag{7}\\] The loss function 6 is usually employed when the output (response) variable assumes continuous values, while the 7 is used for binary output variables.\nAfter choosing an appropriate loss function, the cost function is defined as the average of the loss function over all the observation, that is \\[\nC(\\mathbf{y}; \\mathbf{x}, \\mathbf{W}) = \\frac{1}{n} \\sum_{i = 1}^{n}\nL(\\mathbf{w_i, \\mathbf{x}_i; y_i}) + \\lambda J(\\mathbf{W}),\n\\] where \\(J(\\mathbf{W})\\) is a non-negative regularization term and \\(\\lambda \\geq 0\\) is a tuning parameter.\nIn practice, we may have a regularization term for each layer, each one having its own \\(\\lambda\\). Some commonly used regularization terms are \\[\nJ(\\mathbf{W}) = \\frac{1}{2} \\sum_{k = 1}^{K - 1} \\lVert \\mathbf{w}^{(k)} \\rVert^2,\n\\] and \\[\nJ(\\mathbf{W}) = \\frac{1}{2} \\sum_{k = 1}^{K - 1} \\lVert \\mathbf{w}^{(k)} \\rVert,\n\\] where \\(K\\) is the number of layers of our neural network model, and \\(\\mathbf{w}^{(k)}\\) is the vector of weights from the units in the layer \\(L_k\\) to the layer \\(L_{k + 1}\\). Note that, these two regularization terms are analogous to the Ridge and Lasso penalizations, and they play the exact same role in neural networks as its analogous versions do for the linear models (Efron and Hastie 2016). Mixtures of these two regularization terms, as in the elastic net (Zou and Hastie 2005), are also common.\n\n\nFitting a Neural Network\nSupposing a user has set the number of layers, units, an activation function and a loss function, to fit a neural network we seek the set of weights \\(\\mathbf{W} = \\{ \\mathbf{W}^{(1)}, \\ldots, \\mathbf{W}^{(k - 1)} \\}\\) such that the cost function is minimized, that is \\[\n\\min_{\\mathbf{W}} \\left \\{ \\mathcal{C}(\\mathbf{y}; \\mathbf{X}, \\mathbf{W}) \\right \\}.\n\\] Therefore, the neural network fit has turned into an optimization problem. The most common algorithm used to solve this optimization problem is the Backpropagation algorithm, which is described in the next section for a general situation.\n\n\nBackpropagation\nBackpropagation (or gradient descent) is the method used to find the weights which minimize the chosen cost and loss functions for a given neural network. It is an iterative algorithm that is guaranteed to converge whenever the cost function has a single local minima (Efron and Hastie 2016). However, even if the cost function does not have a single local minima, the algorithm works fairly well. The updates for a weight matrix, \\(\\mathbf{W}^{(k)}\\) let’s say, is done as follows \\[\n\\mathbf{W}^{(k)} = \\mathbf{W}^{(k)} - \\alpha \\frac{\\partial\n\\mathcal{C}(\\mathbf{y}; \\mathbf{X}, \\mathbf{W})}{\\partial \\mathbf{W}^{(k)}},\n\\tag{8}\\] where \\(\\alpha\\) is a tuning parameter called learning rate. The name backpropagation comes from the fact that the derivatives (or gradients) are computed according to something called a computation graph in a backward fashion. It is heavily based on the chain rule for differentiation.\nGiven initial values for the \\(\\mathbf{W}\\) matrices, the method repeats the update rule 8 until convergence. Provided that the columns of the design matrix are rescaled to mean 0 and variance 1, Hastie, Tibshirani, and Friedman (2009) suggest the use of random starting values for the weights as uniform random variables on the interval \\([-.75, .75]\\)."
  },
  {
    "objectID": "posts/lmnet/2021-06-23-lmnnet.html#sec:imple",
    "href": "posts/lmnet/2021-06-23-lmnnet.html#sec:imple",
    "title": "Estimating regression coefficients using a Neural Network (from scratch)",
    "section": "Implementation",
    "text": "Implementation\nI created functions for the implementation of a Neural Network with a single hidden layer model for generic activation functions. The implementation considers the cost function defined as \\[\nC(\\mathbf{y}; \\mathbf{X}, \\mathbf{Y}) = \\frac{1}{n} \\lVert \\mathbf{y} -\n\\hat{\\mathbf{y}} \\rVert^2.\n\\]\nThe inputs for the implemented function are:\n\nA design matrix \\(\\mathbf{X}\\), including the columns of ones for the intercept;\nA column vector \\(\\mathbf{y}\\) containing the response variable;\nThe number of units for the hidden layer;\nThe activation function for the hidden layer;\nThe activation function for the output layer;\nA scalar for the learning rate \\(\\alpha\\);\nTwo control parameters for the convergence of the algorithm. The maximum number of iterations allowed, and a relative error \\(\\epsilon\\) which controls when to stop the iteration algorithm.\n\nThe function returns a list of size 5. Its first element is the predicted vector for \\(\\mathbf{y}\\), the second contains the values of the cost function for each iteration of the algorithm. The third position of this list stores the weight matrices \\(\\mathbf{W}^{(1)}\\) and \\(\\mathbf{W}^{(2)}\\), while the last two positions store the number of iterations until attain the convergence and a string indicating whether the algorithm converged or not, respectively.\nSee below the implementation of some activation functions (and their derivatives)\n\n##--- activation functions and their derivatives ----\n\n## ReLU\nrelu <- function(x) {\n    pmax(x, 0)\n}\n\n## derivative leaky ReLU\nd_relu <- function(x) {\n    ifelse(x > 0, 1, 0)\n}\n\n## leaky ReLU\nlrelu <- function(x) {\n    pmax(x * .01, x)\n}\n\n## derivative leaky ReLU\nd_lrelu <- function(x) {\n    ifelse(x > 0, 1, .01)\n}\n\n## derivative tanh\nd_tanh <- function(x) {\n    1 - (tanh(x)^2)\n}\n\n## derivative logit\nd_logit <- function(x) {\n    plogis(x) * ( 1 - plogis(x) )\n}\n\n## derivative identity\nd_ident <- function(x) {\n    pmax( -2 * abs(x), 1 )\n}\n\nNow, let’s implement some helper functions to fit our neural network models. First, the cost function used in our examples is given by\n\n## cost function\ncost_f <- function(y, yhat) {\n    crossprod(yhat - y) / NROW(y)\n}\n\nThe implementation of the functions that will need to be executed at each step of the optimization algorithm are defined below. compute_nn computes the hidden layers given the matrix of covariates (or features) X, the list containing the the weights W associated to each layer connection, and two activation functions act_hidden and act_out for the hidden and output layers, respectively (this is a the implementation for a 2 layers network). The compute_grad function computes the gradient and needs some further information like y (the response variable), n the sample size, and the derivatives of the activation functions. update_aux and update_w are helper functions used to update the weights.\n\n##--- functiosn to fit the neural network ----\n\n## computing the forward step of the neural network\ncompute_nn <- function(X, W, act_hidden, act_out) {\n    Z <- vector(mode = \"list\", length = 2)\n    \n    Z[[1]] <- X %*% W[[1]]\n    A <- act_hidden(Z[[1]])\n\n    Z[[2]] <- A %*% W[[2]]\n\n    return( list(y = act_out(Z[[2]]),\n                 z = Z) )\n}\n\n## computing the gradient of the neural network\ncompute_grad <- function(y, X, W, act_hidden, act_out,\n                         d1_hidden, d1_out, n) {\n    nn    <- compute_nn(X, W, act_hidden, act_out)\n    aux_out <- (nn$y - y) * d1_out(nn$z[[2]])\n    aux_hid <- tcrossprod(aux_out, W[[2]]) *\n        d1_hidden(nn$z[[1]])\n    \n    return(\n        list(crossprod(X, aux_hid) / n,\n             crossprod(act_hidden(nn$z[[1]]), aux_out) / n)\n    )\n}\n\n## aux function for updating W\nupdate_aux <- function(w, dw, alpha) {\n    w - alpha * dw\n}\n\n## update the weights of a neural network\nupdate_w <- function(W, alpha, y, X, act_hidden, act_out,\n                     d1_hidden, d1_out, n) {\n\n    grad_w <- compute_grad(y, X, W, act_hidden, act_out,\n                           d1_hidden, d1_out, n)\n    \n    return( Map(f = update_aux, w = W,\n                dw = grad_w, alpha = alpha) )\n}\n\nFinally, all these functions previously describer are used to build the fit_nn function (which is used to compute the optimal weights for the neural network). The alpha is the \\(\\alpha\\) previously mentioned in this post, maxit and eps are parameters used in the optimization process. The first one stands for the maximum number of iterations to be used in the optimization process, while the second stand for the “optimization error”. That is, if, from one iteration to another, the change between the weights does not exceed eps, then we consider that the algorithm converged and a (maybe local) optimum has been found.\n\nfit_nn <- function(y, X, hid_units,\n                   act_hidden, act_out,\n                   d1_hidden, d1_out,\n                   alpha = .25,\n                   maxit = 500L,\n                   eps   = 1e-05) {\n    m <- hid_units\n    p <- ncol(X)\n    N <- NROW(y)\n\n    \n    W <- list(matrix(runif(m * p, -.75, .75),\n                     ncol = m, nrow = p),\n              matrix(runif(m, -.75, .75), ncol = 1))\n\n    nn   <- vector(mode = \"list\", length = maxit)\n    cost <- vector(mode = \"numeric\", length = maxit)\n\n    ## initialiazing\n    nn[[1]] <- compute_nn(X, W, act_hidden, act_out)\n\n    cost[1] <- cost_f(y, nn[[1]]$y)\n    \n    for( i in seq_len(maxit)[-1] ) {\n        W <- update_w(W, alpha, y, X,\n                      act_hidden, act_out,\n                      d1_hidden, d1_out,\n                      n = N)\n        \n        nn[[i]] <- compute_nn(X, W, act_hidden, act_out)\n        cost[i] <- cost_f(y, nn[[i]]$y)\n        \n        if( abs(cost[i] - cost[i - 1]) < eps ) {\n            output <- list(nn   = nn[[i - 1]],\n                           cost = cost[1:(i - 1)],\n                           W    = W,\n                           it   = (i - 1),\n                           conv = \"yes\")\n            break\n        }\n    }\n\n    if( i == maxit ) {\n        output <- list(yhat = nn[[maxit]]$y,\n                       cost = cost[1:maxit],\n                       W    = W,\n                       it   = maxit,\n                       conv = \"no\")\n    }\n\n    return(output)\n}\n\nHaving all these functions, we can play with some numerical examples!"
  },
  {
    "objectID": "posts/lmnet/2021-06-23-lmnnet.html#sec:ne",
    "href": "posts/lmnet/2021-06-23-lmnnet.html#sec:ne",
    "title": "Estimating regression coefficients using a Neural Network (from scratch)",
    "section": "Numerical Examples",
    "text": "Numerical Examples\n\n\n\n\nExample 1: Equivalence between Neural Network and Linear Model\n\n\n\nConsider a simulated dataset where \\[\n\\mathbf{y} \\sim N(\\mathbf{X} \\boldsymbol{\\beta}, \\sigma^2 \\mathbf{I}_n),\n\\] where \\(\\mathbf{X} \\in {\\rm I\\!R}^{n \\times 3}\\), with the first column being the intercept term. To simulate the model we used \\(\\boldsymbol{\\beta} = (2, 3, 1.5)\\). Additionally, suppose \\(n = 2000\\).\nConsidering the identity function as the activation function for both layers, the goal here is to show that the \\(\\mathbf{W}^{(1)} \\mathbf{W}^{(2)} = \\hat{\\boldsymbol{\\beta}}\\), where \\(\\hat{\\boldsymbol{\\beta}}\\) is the least squares solution for a linear model established as \\(\\mathbf{y} = \\mathbf{X} \\boldsymbol{\\beta}\\), and \\(\\mathbf{W}^{(1)}, \\, \\mathbf{W}^{(2)}\\) are the optimal weights according to the Neural Network fitted to the data, as proved in the subsection @ref(subsec:act).\nTable 1 displays the results from the simulated example. The two different approaches have yielded the exactly same results. If we were to make predictions, the two methods would provide the same predicted values under these circumstances.\n\n\n\n\nTable 1: Comparing the LS solution and the product of the neural network weight matrices.\n\n\n\\(\\hat{\\boldsymbol{\\beta}}\\)\n\\(\\mathbf{W}^{(1)} \\mathbf{W}^{(2)}\\)\n\n\n\n\n2.996\n2.996\n\n\n3.004\n3.004\n\n\n1.512\n1.512\n\n\n\n\n\n\nSee below the code used on this example.\n\n##--- numerical examples ----\n\n##--- example 1 ----\n\nset.seed(123)\n\nn <- 2000\n\nx1 <- rnorm(n)\nx2 <- as.numeric( scale( rexp(n) ) )\n\ny <- 3 + 3 * x1 + 1.5 * x2 + rnorm(n, sd = .5)\n\nmy_x <- cbind( rep(1, n), x1, x2 )\ncolnames(my_x) <- NULL\n\ndt <- as.data.frame( cbind(y, my_x[, 2:3]) )\nnames(dt) <- c(\"y\", \"x1\", \"x2\")\n\nm <- 6\n\nfit_1 <-\n    fit_nn(y = y, X = my_x,\n           hid_units = m,\n           act_hidden = identity,\n           act_out    = identity,\n           d1_hidden  = d_ident,\n           d1_out     = d_ident,\n           alpha = .05,\n           maxit = 1000L,\n           eps   = 1e-16)\n\nbeta_hat <- coef(lm(y ~ x1 + x2, data = dt))\n\ntbl_1 <- as.data.frame(cbind(beta_hat,\n                             fit_1$W[[1]] %*% fit_1$W[[2]]))\nnames(tbl_1) <- c(\"$\\\\hat{\\\\boldsymbol{\\\\beta}}$\",\n                  \"$\\\\mathbf{W}^{(1)} \\\\mathbf{W}^{(2)}$\")\nrownames(tbl_1) <- NULL\n\n\n\nExample 2: Nonlinear relationship and number of hidden units\n\n\n\nConsider now the following model \\[\ny_i = \\beta_0 + \\beta_1 (x^2) + \\varepsilon_i.\n\\]\nIn practice, we do not know before-hand the relationship between the response and explanatory variables is not linear. In fig-fit-nn2, we show the fitted curves the linear model and for neural networks under different settings for a dataset simulated from this example. The Neural Network deals nicely with the nonlinearity at the cost of possibly overfit the data.\n\n\n\n\n\nFigure 4: Different models fitted to the same simulated dataset.\n\n\n\n\nSee the code used on this example below.\n\n##--- example 2 ----\n\nset.seed(124)\n\nx12 <- rnorm(n)\n\ny2 <- 5 - 2.5 * (x12^2) + rnorm(n, sd = .5)\n\nmy_x2 <- cbind(rep(1, n), x12)\ncolnames(my_x2) <- NULL\n\ndt2 <- as.data.frame( cbind(y2, my_x2[, 2]) )\nnames(dt2) <- c(\"y\", \"x1\")\n\nn_pred <- 4000\n\n## fitting linear model\n\nmy_lm2 <- lm(y ~ x1, data = dt2)\n\n## fitting neural network with tanh as the activation function for the hidden\n## layer - 5 hidden units\nfit_2 <-\n    fit_nn(y = y2, X = my_x2,\n           hid_units  = 5,\n           act_hidden = tanh,\n           act_out    = identity,\n           d1_hidden  = d_tanh,\n           d1_out     = d_ident,\n           alpha = .05,\n           maxit = 1000L,\n           eps   = 1e-04)\n\n## fitting neural network with tanh as the activation function for the hidden\n## layer - 15 hidden units\nfit_3 <-\n    fit_nn(y = y2, X = my_x2,\n           hid_units  = 15,\n           act_hidden = tanh,\n           act_out    = identity,\n           d1_hidden  = d_tanh,\n           d1_out     = d_ident,\n           alpha = .05,\n           maxit = 1000L,\n           eps   = 1e-04)\n\n## fitting neural network with leaky ReLU as the activation function for the\n## hidden layer - 10 hidden units\nfit_4 <-\n    fit_nn(y = y2, X = my_x2,\n           hid_units  = 10,\n           act_hidden = lrelu,\n           act_out    = identity,\n           d1_hidden  = d_lrelu,\n           d1_out     = d_ident,\n           alpha = .05,\n           maxit = 1000L,\n           eps   = 1e-04)\n\npred_data <- data.frame(x = seq(from = min(x12), to = max(x12),\n                                length.out = n_pred))\n\npred_data <- transform(pred_data,\n                       lm = coef(my_lm2)[[1]] + coef(my_lm2)[[1]] * x)\n\npred_data <- transform(pred_data,\n                       nn_tanh_1 =\n                           compute_nn(X = cbind(rep(1, 4000),\n                                                x),\n                                      W = fit_2$W,\n                                      act_hidden = tanh,\n                                      act_out = identity)$y)\n\npred_data <- transform(pred_data,\n                       nn_tanh_2 =\n                           compute_nn(X = cbind(rep(1, 4000),\n                                                x),\n                                      W = fit_3$W,\n                                      act_hidden = tanh,\n                                      act_out = identity)$y)\n\npred_data <- transform(pred_data,\n                       nn_lrelu =\n                           compute_nn(X = cbind(rep(1, 4000),\n                                                x),\n                                      W = fit_4$W,\n                                      act_hidden = lrelu,\n                                      act_out = identity)$y)\n\nsetDT(pred_data)\n\npred_data <- melt(pred_data, id = 1,\n                  value.name = \"pred\",\n                  variable.name = \"method\")\n\npred_data[, method := fcase(method == \"nn_tanh_1\", \"tanh - 5\",\n                            method == \"nn_tanh_2\", \"tanh - 15\",\n                            method == \"nn_lrelu\", \"leaky ReLU - 10\",\n                            default = \"lm\")]\n\nggplot(data = pred_data) +\n    geom_point(data = dt2, aes(x = x1, y = y),\n               alpha = .5) +\n    geom_line(aes(x = x, y = pred, color = method),\n              lwd = 1.05) +\n    scale_color_discrete(name = NULL) +\n    theme_bw() +\n    theme(\n        legend.position = \"bottom\",\n        legend.margin = margin(6, 6, 6, 6)\n    ) +\n    labs(x = \"X\", y = \"Y\")"
  },
  {
    "objectID": "posts/lmnet/2021-06-23-lmnnet.html#final-thoughts",
    "href": "posts/lmnet/2021-06-23-lmnnet.html#final-thoughts",
    "title": "Estimating regression coefficients using a Neural Network (from scratch)",
    "section": "Final Thoughts",
    "text": "Final Thoughts\nThe Neural Network Regression models are very interesting but certainly are not magical as it is sold in the market. By the end of the day, these models consist of simple linear algebra allied to the use of element-wise nonlinear functions and optimization algorithms. Speaking on optimization algorithm, the gradient descent looks like a fixed-point iteration algorithm. These kind of algorithms have the advantage of not need the second derivative of the functions, however their convergence can be slow. I believe that using different learning rates for different parameters could improve the speed on which the algorithm converges.\nAlthough these models do not make any distributional assumption on the data, we can easily make it more suitable for certain distributions by working with the cost and activation functions on an appropriate fashion.\nThere are several variants of these models suited for different problems, like text and image classification, for example. The idea is the same, what changes is the way the researchers deal with the hidden layers. I think an interesting application is to try to use neural networks to estimate non-parametrically covariance matrices for spatial data."
  },
  {
    "objectID": "posts/models/models.html",
    "href": "posts/models/models.html",
    "title": "All models are wrong",
    "section": "",
    "text": "George Box’s 1976 paper named “Science and Statistics” is famous for that “all models are wrong” quote. Unfortunately, The number of people who know this quote is larger than those who have read the paper entirely.\nThe paper provides interesting (and insightful) discussions that still apply to the field of statistics nowadays. In my opinion, one of the most remarkable things Dr. Box pointed out is about “Mathematistry,” he defines (or explains) it as follows: > “Mathematistry is characterized by development of theory for theory’s sake, > which since it seldom touches down with practice, has a tendency to redefine > the problem rather than solve it.”\nLater on, in the same paper, he mentions how this “malady” (in his words) is harmful to statistics as a field. > “An even more serious consequence of mathematistry concerns the training of > statisticians. We have recently been passing through a period where nothing > very much was expected of the statistician. A great deal of research money > was available and one had the curious situation where the highest objective of > the teacher of statistics was to produce a student who would be another > teacher of statistics. It was thus possible for successive generations of > teachers to be produced with no practical knowledge of the subject whatever. > Although statistics departments in universities are now commonplace there > continues to be a severe shortage of statisticians competent to deal with real > problems. But such are needed.”\nWe still face these challenges (on many others he mentioned in that paper) in Statistics. Therefore, it would be nice to share this to make people think about it."
  },
  {
    "objectID": "publications.html",
    "href": "publications.html",
    "title": "Statistical Data Science Lab",
    "section": "",
    "text": "Publications\n\n\n\n\n\nArqub, S. A., Bashir, R., Obeng, K., Godoy, L. da C., Kuo, C.-L., Upadhyay, M., & Yadav, S. (2023). Survival and failure rate of lower lingual bonded retainers: A retrospective cohort evaluation. Orthodontics & Craniofacial Research, 26(2), 256–264. https://doi.org/https://doi.org/10.1111/ocr.12608\n\n\nFrank, S., Ibrahim, B., Feng, R., Bidra, A., Lafreniere, D., Kuo, C.-L., Godoy, L. da C., & Falcone, T. E. (2023). Tolerability of nasal and oral povidone-iodine antisepsis for in-office procedures. Clinical Otolaryngology, 48(4), 696–699. https://doi.org/https://doi.org/10.1111/coa.14045\n\n\nKuo, C.-L., Liu, R., Godoy, L. da C., Pilling, L. C., Fortinsky, R. H., & Brugge, D. (2023). Association between residential exposure to air pollution and incident coronary heart disease is not mediated by leukocyte telomere length: A UK biobank study. Toxics, 11(6). https://doi.org/10.3390/toxics11060489\n\n\nLeonard, J. F., Taxel, P., Kuo, C.-L., Godoy, L. da C., & Freilich, M. (2023). Dental implant and bone augmentation treatment in bone-compromised patients: Oral health-related quality of life outcomes. The Journal of Prosthetic Dentistry. https://doi.org/10.1016/j.prosdent.2023.01.011\n\n\nTurshudzhyan, A., Godoy, L. da C., Kuo, C.-L., & Wu, G. Y. (2023). Alpha feto-protein expression trends for screening early hepatocellular carcinoma. Gene Expression, 000, 0–0.\n\n\nArqub, S. A., Banankhah, S., Sharma, R., Godoy, L. da C., Kuo, C.-L., Ahmed, M., Alfardan, M., & Uribe, F. (2022). Association between initial complexity, frequency of refinements, treatment duration, and outcome in invisalign orthodontic treatment. American Journal of Orthodontics and Dentofacial Orthopedics. https://doi.org/10.1016/j.ajodo.2022.06.017\n\n\nGodoy, L. da C. (2022). Smile: Spatial misalignment: Interpolation, linkage, and estimation. https://CRAN.R-project.org/package=smile\n\n\nGodoy, L. da C., Assunção, R. M., & Butler, K. A. (2022). Testing the spatial association of different types of polygons. Spatial Statistics, 51, 100695. https://doi.org/10.1016/j.spasta.2022.100695\n\n\nGodoy, L. da C., Prates, M. O., & Yan, J. (2022). An unified framework for point-level, areal, and mixed spatial data: The hausdorff-gaussian process. arXiv. https://doi.org/10.48550/ARXIV.2208.07900\n\n\nHariharan, A., Arqub, S. A., Gandhi, V., Godoy, L. da C., Kuo, C.-L., & Uribe, F. (2022). Evaluation of interproximal reduction in individual teeth, and full arch assessment in clear aligner therapy: Digital planning versus 3D model analysis after reduction. Progress in Orthodontics, 23(1), 1–10.\n\n\nKumar, M., Patil, S., Godoy, L. da C., Kuo, C.-L., Swede, H., Kuchel, G. A., & Chen, K. (2022). Demand ischemia as a predictor of mortality in older patients with delirium. Frontiers in Cardiovascular Medicine, 9.\n\n\nPrates, M. O., Azevedo, D. R. M., Godoy, L. da C., & Bandyopadhyay, D. (2022). Can gaussian markov random fields handle spatial confounding? Journal of the Indian Statistical Association.\n\n\nArqub, S. A., Voldman, R., Ahmida, A., Kuo, C.-L., Godoy, L. da C., Nasrawi, Y., Al-Khateeb, S. N., & Uribe, F. (2021). Patients’ perceptions of orthodontic treatment experiences during COVID-19: A cross-sectional study. Progress in Orthodontics, 22(1), 1–12.\n\n\nBoutrous, M. L., Maseto, N., Kuo, C.-L., Godoy, L. da C., & Amankwah, K. (2021). The use of multiple carotid stents is associated with increased incidence of developing in-stent stenosis on long-term follow-up. Journal of Vascular Surgery, 74(3), e240–e241.\n\n\nHuynh, C., Godoy, L. da C., Kuo, C.-L., Smeds, M., & Amankwah, K. S. (2021). Examining the development of operative autonomy in vascular surgery training and when trainees and program directors agree and disagree. Annals of Vascular Surgery, 74, 1–10.\n\n\nLin, G., Murase, J. E., Murrell, D. F., Godoy, L. da C., & Grant-Kels, J. M. (2021). The impact of gender in mentor-mentee success: Results from the women’s dermatologic society mentorship survey. International Journal of Women’s Dermatology."
  },
  {
    "objectID": "publications3.html",
    "href": "publications3.html",
    "title": "Statistical Data Science Lab",
    "section": "",
    "text": "Publications\n\n\n\n\n\nLeonard, J. F., Taxel, P., Kuo, C.-L., Godoy, L. da C., & Freilich, M. (2023). Dental implant and bone augmentation treatment in bone-compromised patients: Oral health-related quality of life outcomes. The Journal of Prosthetic Dentistry. https://doi.org/10.1016/j.prosdent.2023.01.011\n\n\nArqub, S. A., Banankhah, S., Sharma, R., Godoy, L. da C., Kuo, C.-L., Ahmed, M., Alfardan, M., & Uribe, F. (2022). Association between initial complexity, frequency of refinements, treatment duration, and outcome in invisalign orthodontic treatment. American Journal of Orthodontics and Dentofacial Orthopedics. https://doi.org/10.1016/j.ajodo.2022.06.017\n\n\nArqub, S. A., Bashir, R., Obeng, K., Godoy, L. da C., Kuo, C.-L., Upadhyay, M., & Yadav, S. (2022). Survival and failure rate of lower lingual bonded retainers: A retrospective cohort evaluation. Orthodontics & Craniofacial Research. https://doi.org/10.1111/ocr.12608\n\n\nGodoy, L. da C. (2022). Smile: Spatial misalignment: Interpolation, linkage, and estimation. https://CRAN.R-project.org/package=smile\n\n\nGodoy, L. da C., Assunção, R. M., & Butler, K. A. (2022). Testing the spatial association of different types of polygons. Spatial Statistics, 51, 100695. https://doi.org/10.1016/j.spasta.2022.100695\n\n\nGodoy, L. da C., Prates, M. O., & Yan, J. (2022). An unified framework for point-level, areal, and mixed spatial data: The hausdorff-gaussian process. arXiv. https://doi.org/10.48550/ARXIV.2208.07900\n\n\nHariharan, A., Arqub, S. A., Gandhi, V., Godoy, L. da C., Kuo, C.-L., & Uribe, F. (2022). Evaluation of interproximal reduction in individual teeth, and full arch assessment in clear aligner therapy: Digital planning versus 3D model analysis after reduction. Progress in Orthodontics, 23(1), 1–10.\n\n\nKumar, M., Patil, S., Godoy, L. da C., Kuo, C.-L., Swede, H., Kuchel, G. A., & Chen, K. (2022). Demand ischemia as a predictor of mortality in older patients with delirium. Frontiers in Cardiovascular Medicine, 9.\n\n\nPrates, M. O., Azevedo, D. R. M., Godoy, L. da C., & Bandyopadhyay, D. (2022). Can gaussian markov random fields handle spatial confounding? Journal of the Indian Statistical Association.\n\n\nArqub, S. A., Voldman, R., Ahmida, A., Kuo, C.-L., Godoy, L. da C., Nasrawi, Y., Al-Khateeb, S. N., & Uribe, F. (2021). Patients’ perceptions of orthodontic treatment experiences during COVID-19: A cross-sectional study. Progress in Orthodontics, 22(1), 1–12.\n\n\nBoutrous, M. L., Maseto, N., Kuo, C.-L., Godoy, L. da C., & Amankwah, K. (2021). The use of multiple carotid stents is associated with increased incidence of developing in-stent stenosis on long-term follow-up. Journal of Vascular Surgery, 74(3), e240–e241.\n\n\nHuynh, C., Godoy, L. da C., Kuo, C.-L., Smeds, M., & Amankwah, K. S. (2021). Examining the development of operative autonomy in vascular surgery training and when trainees and program directors agree and disagree. Annals of Vascular Surgery, 74, 1–10.\n\n\nLin, G., Murase, J. E., Murrell, D. F., Godoy, L. da C., & Grant-Kels, J. M. (2021). The impact of gender in mentor-mentee success: Results from the women’s dermatologic society mentorship survey. International Journal of Women’s Dermatology."
  }
]